
Help text file for bch.exe program that generate binary (n,k) BCH code.

bch.exe program uses following input files:
bch.in - to specify input parameters of BCH code, only this file 
	should be changed (if the bch.exe cannot find bch.in file then
	it requests the user to type BCH code and program parameters
bch.vht - data needed to generate enc.vhd and sim.vhd and sim.txt files
bch1.vht - data needed to generate dec.vhd if t (no. of errors) = 1
bch2.vht - data needed to generate dec.vhd if t = 2
bch3.vht - data needed to generate dec.vhd if t > 2
bchs.vht - data needed to generate sym.cmd and sym.cme

bch.exe generates (overwrites !!!) following files:
const.vhd - VHDL package file that contains useful constants
enc.vhd - VHDL file for generating BCH code encoder
dec.vhd - VHDL file for generating BCH code decoder
sim.vhd - VHDL file for generating file for simulation encoder and decoder
sim.cmd - command file for simulation before synthesis
sim.cme - command file for simulation after synthesis

bch.in file should consists of following:
m= xx - specify width of Galois Field GF(2^m), n=2^m-1
t= xx - specify number of errors to be may corrected
program option (placed in bch.in):
-oxx - for t>2 circuit option;
	xx = 2 - parallel architecture
	xx = 3 - serial architecture - preferred.
-sxx - generate sym.cmd and sym.cme with specified 
	by xx simulation time (number of codewords to simulate)
	xx=0 - do not generate simulation command files.
-ix - xx - interleave number. The frequency of Berlekamp-Massey 
	Algorithm in comparison to data transfer (syndrome calculation) frequency.
	f_BMA = interleave * f_syn
-mxx - design optimization by extracting
	xx= 0 -  without optimisation
	xx= 1,2... - with optimization - introduce a new intermediate
		signal only if it reduces the number of XOR at least by xx



There are following BCH codes for m= 5 and t<=3. (n,k,t)
(31, 26, 1) 	(31, 21, 2) 	(31, 16, 3) 	



	---------------- ENCODER----------------

ering - LFSR Linear Feedback Shift Registers
		Reg= 15		XOR= 9
ecount - counter (control system)
		Reg= 6		XOR= 1
ENCODER --
		Reg= 1		XOR= 0
	total	Reg= 22		XOR= 10




	-------------- DECODER ---------------

--------------- Syndromes calculation ------------
dsyn1 - syndromes  1 2 4
		Reg= 5		XOR= 7
dsyn3 - syndromes  3
		Reg= 5		XOR= 4
dsyn5 - syndromes  5
		Reg= 5		XOR= 8
	total	Reg= 15		XOR= 19

--------------- Chien Search ------------
dcheq - check if Chien search equal zero - found an error
		Reg= 0		XOR= 15
drdce - m registers for x^0
		Reg= 5		XOR= 0
dch1 - Chien Search for x^1
		Reg= 5		XOR= 1
dch2 - Chien Search for x^2
		Reg= 5		XOR= 2
dch3 - Chien Search for x^3
		Reg= 5		XOR= 3
	total	Reg= 20		XOR= 21

--------------- Syndromes rearranging ------------
dmul21 - 2 to 1 multiplexers 
		Reg= 0 * 4 = 0	XOR= 0 * 4 = 0
drdce - m registers with clock enable
		Reg= 5 * 5 = 25	XOR= 0 * 5 = 0
	total	Reg= 25		XOR= 0

--------------- Berlekamp-Massey Algorithm ----
dmul21 - 2 to 1 multiplexers
		Reg= 0 * 2 = 0	XOR= 0 * 2 = 0
drdceSOne - m registers with set to one
		Reg= 5 * 4 = 20	XOR= 0 * 4 = 0
drdcer - m registers with reset
		Reg= 5 * 2 = 10	XOR= 0 * 2 = 0
dxorm - m * XOR - modulo 2 addition
		Reg= 0 * 2 = 0	XOR= 5 * 2 = 10
dpm - bit-parallel standard basis multiplier option L
		Reg= 0 * 10 = 0	XOR= 24 * 10 = 240
dxort - modulo 2 addition
		Reg= 0 * 5 = 0	XOR= 2 * 5 = 10
drdce - m registers
		Reg= 5 * 2 = 10	XOR= 0 * 2 = 0
	total	Reg= 40		XOR= 260

--------------- The buffer  ----
dbuf - buffer for storing data to be corrected
		Reg= 26		XOR= 1
	total	Reg= 26		XOR= 1

--------------- The control system  ----
dca - less signficant control counter
		Reg= 2		XOR= 1
dcb - more signficant control counter
		Reg= 4		XOR= 3
dcl - degree of error polynomial
		Reg= 3		XOR= 3
drd1ce - single register
		Reg= 1 * 5 = 5	XOR= 0 * 5 = 0
dcount - control system
	total	Reg= 14		XOR= 7


	DECODER total
		Reg= 140		XOR= 308



GF(2^5) generated by polynomial: 1 + x^2 + x^5
  no.  Standard    Dual basis
   -   00000     00000
   0   10000     01000
   1   01000     10000
   2   00100     00001
   3   00010     00010
   4   00001     00100
   5   10100     01001
   6   01010     10010
   7   00101     00101
   8   10110     01011
   9   01011     10110
  10   10001     01100
  11   11100     11001
  12   01110     10011
  13   00111     00111
  14   10111     01111
  15   11111     11111
  16   11011     11110
  17   11001     11100
  18   11000     11000
  19   01100     10001
  20   00110     00011
  21   00011     00110
  22   10101     01101
  23   11110     11011
  24   01111     10111
  25   10011     01110
  26   11101     11101
  27   11010     11010
  28   01101     10101
  29   10010     01010
  30   01001     10100
  31   10000     01000