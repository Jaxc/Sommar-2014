-- File generated by bch.exe program.
-- The decoder for BCH code (63,45), t=3
-- Option= 2,  Interleave= 1, -- with optimization= 1.
-- GF(2^6) is generated by polynomial [1+x+...] - 1100001;
 

-------------------------------------------------------------------
-- 2-1 multiplexer

	USE WORK.const.ALL;
ENTITY dmul21 IS
PORT ( sel: IN BIT;
	d0, d1: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1));  
END dmul21;

ARCHITECTURE dmul21a OF dmul21 IS
  BEGIN
	gen:
	FOR i IN 0 TO m-1 GENERATE
	  dout(i)<= (NOT sel AND d0(i)) OR (sel AND d1(i));
	END GENERATE;
END dmul21a;

--------------------------------------------------------------------
-- single register with clock enable

ENTITY drd1ce IS
PORT ( clk, ce, din: IN BIT; 
	dout: OUT BIT);  
END drd1ce;

ARCHITECTURE drd1cea OF drd1ce IS
	SIGNAL q: BIT;
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF ce='1' THEN
		q<= din;
	ELSE
		q<= q;
	END IF;
  END PROCESS;
END drd1cea;

--------------------------------------------------------------------
-- PIPO registers m bits wide with clock enable and reset

	USE WORK.const.ALL;
ENTITY drdcer IS
PORT ( clk, ce, reset: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1));  
END drdcer;

ARCHITECTURE drdcera OF drdcer IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	FOR i IN 0 TO m-1 LOOP
	  IF reset='1' THEN
		q(i)<= '0';
	  ELSIF ce='1' THEN
		q(i)<= din(i);
          ELSE 
		q(i)<= q(i);
	  END IF;
	END LOOP;
  END PROCESS;
END drdcera;

--------------------------------------------------------------------
-- PIPO registers m bits wide with clock enable and set to one

	USE WORK.const.ALL;
ENTITY drdceSOne IS
PORT ( clk, ce, set, dinone: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1));  
END drdcesone;

ARCHITECTURE drdcesonea OF drdcesone IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF set='1' THEN 
		q(0)<= dinone;
	ELSIF ce='1' THEN
		q(0)<= din(0);
	ELSE
		q(0)<= q(0);
	END IF;
	
	FOR i IN 1 TO m-1 LOOP
	  IF set='1' THEN
		q(i)<= '0';
	  ELSIF ce='1' THEN
		q(i)<= din(i);
	  ELSE
		q(i)<= q(i);
          END IF;
	END LOOP;
  END PROCESS;
END drdcesonea;


--------------------------------------------------------------------
-- m registers with clock enable

	USE WORK.const.ALL;
ENTITY drdce IS
PORT ( clk, ce: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1));  
END drdce;

ARCHITECTURE drdcea OF drdce IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF ce='1' THEN
		q<= din;
	ELSE
		q<= q;
	END IF;
  END PROCESS;
END drdcea;
--------------------------------------------------------------------
-- PIPO registers m bits wide

	USE WORK.const.ALL;
ENTITY drd IS
PORT (clk: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1));  
END drd;

ARCHITECTURE drda OF drd IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	q<= din;
  END PROCESS;
END drda;

-- sum m * XOR; dout<= din0 XOR din1

	USE WORK.const.ALL;
ENTITY dxorm IS
PORT (din0, din1: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dxorm;

ARCHITECTURE dxorma OF dxorm IS
  BEGIN
	dout<= din0 XOR din1;
END dxorma;

-----------------------------------------------------------------

--------------- OPTION 3 -serial
-------------------------------------------------------------------
-- Serial In Parallel Out m bits shift register

	USE WORK.const.ALL;
ENTITY dsipo IS
PORT (clk, din: IN BIT;
	dout: OUT BIT_VECTOR(0 TO m-1)); 
END dsipo;

ARCHITECTURE dsipoa OF dsipo IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	q<= din & q(0 TO m-2);
  END PROCESS;
END dsipoa;

-------------------------------------------------------------------
-- Shift register with serial XOR, and parallel in

	USE WORK.const.ALL;
ENTITY dshpe IS
PORT (clk, ce, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1); -- parallel in
	dout: OUT BIT_VECTOR(0 TO m-1)); 
END dshpe;

ARCHITECTURE dshpea OF dshpe IS
	SIGNAL ring: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= ring;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe= '1' THEN
	  ring<= din;	
	ELSIF ce='1' THEN
	  ring<= ring(m-1) & ring(0 TO m-2);
	END IF;
  END PROCESS;
END dshpea;

-------------------------------------------------------------------
-- Shift register with serial XOR, and reset

	USE WORK.const.ALL;
ENTITY dshr IS
PORT (clk, ce, reset, din: IN BIT;
	dout: OUT BIT_VECTOR(0 TO m-1)); 
END dshr;

ARCHITECTURE dshra OF dshr IS
	SIGNAL ring: BIT_VECTOR(0 TO m-1);
	SIGNAL dmul1: BIT;
  BEGIN
	dout<= ring;
	dmul1<= ring(m-1) XOR din;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF reset='1' THEN 
	  ring(0)<= '0';
	ELSIF ce='1' THEN 
	  ring(0)<= ring(m-1) XOR din;
	END IF;	

	FOR i IN 1 TO m-1 LOOP
	  IF reset= '1' THEN
	    ring(i)<= '0';	
	  ELSIF ce='1' THEN
	    ring(i)<= ring(i-1);
	  END IF;
	END LOOP;
  END PROCESS;
END dshra;

---------------------------------------------------------------------
-- dout<= en And din

	USE WORK.const.ALL;
ENTITY dandm IS
PORT (en: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1)); 
END dandm;

ARCHITECTURE dandma OF dandm IS
  BEGIN
	gen:
	FOR i IN 0 TO m-1 GENERATE
	  dout(i)<= din(i) AND en;
	END GENERATE;
END dandma;


---------------------------------------------------------------------
---------------------------------------------------------------------
-- buffer circuit

	USE WORK.const.ALL;
ENTITY dbuf IS
PORT (clk, bufCe, bufkCe, err, vdout1, din: IN BIT;
	dout: OUT BIT); 
END dbuf;

ARCHITECTURE dbufa OF dbuf IS
	CONSTANT buf_size: INTEGER:= 9; 
	-- buf_size= chpe/interleave + 2 if buf_size<k+1; else buf_size= k 
	SIGNAL bufk: BIT_VECTOR(0 TO k-1); 
	-- bufk - first buffer for storing only first k bits
	SIGNAL buf: BIT_VECTOR(0 TO buf_size-1); -- second buffer
  BEGIN
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF bufCe='1' THEN
		buf<= bufk(k-1) & buf(0 TO buf_size-2);
	END IF;
	IF bufkCe='1' THEN
		bufk<= din & bufk(0 TO k-2);
	END IF;
	dout<= (buf(buf_size-1) XOR err) AND vdout1;
  END PROCESS;
END dbufa;

-----------------------------------------------------------------
-- Bit-Serial Berlekamp (Dual Basis) Multiplier without registers

	USE WORK.const.ALL;
ENTITY dsdbm IS
PORT (dbin, sbin: IN BIT_VECTOR(0 TO m-1); -- standard & dual basis input
	dout: OUT BIT); -- serial output 
END dsdbm;

ARCHITECTURE dsdbma OF dsdbm IS
	SIGNAL dxor: BIT_VECTOR(0 TO m-1); -- xor gates signals
  BEGIN
	dout<= dxor(m-1);
	dxor(0)<= sbin(0) AND dbin(0);
	gen:
	FOR i IN 1 TO m-1 GENERATE
	  dxor(i)<= dxor(i-1) XOR (sbin(i) AND dbin(i));
	END GENERATE;
END dsdbma;

-----------------------------------------------------------------
--  Bit-Serial Berlekamp (Dual Basis) Multiplier LFSR

	USE WORK.const.ALL;
ENTITY dsdbmRing IS
PORT (clk, pe: IN BIT;   -- pe- parallel enable
	din: IN BIT_VECTOR(0 TO m-1); -- dual basis input
	dout: OUT BIT_VECTOR(0 TO m-1)); 
END dsdbmRing;

ARCHITECTURE dsdbmRinga OF dsdbmRing IS
	SIGNAL ring: BIT_VECTOR(0 TO m-1); 
  BEGIN
	dout<= ring;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN 
	  ring<= din;
	ELSE
	  ring(0 TO m-2)<= ring(1 TO m-1);
	  ring(m-1)<= ring(0) XOR ring(1);
	END IF;
  END PROCESS;
END dsdbmRinga;

-------------------------------------------------------------------
-- Bit-Parallel Dual-Basis Multiplier

	USE WORK.const.ALL;
ENTITY dpdbm IS
PORT (ddin, dsin: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1));  
END dpdbm;

ARCHITECTURE dpdbma OF dpdbm IS
	COMPONENT dsdbm -- Serial Dual Basis Multiplier without registers
	  PORT (dbin, sbin: IN BIT_VECTOR(0 TO m-1); 
	  	  -- dual & standard basis in
		dout: OUT BIT); 
	  END COMPONENT;
	  FOR ALL: dsdbm USE ENTITY WORK.dsdbm (dsdbma);

	SIGNAL aux: BIT_VECTOR(0 TO m-2); -- auxiliary signals
	SIGNAL m0in, m1in, m2in, m3in, m4in, m5in: BIT_VECTOR(0 TO m-1);
  BEGIN
	aux(0)<= ddin(0) XOR ddin(1);
	aux(1)<= ddin(1) XOR ddin(2);
	aux(2)<= ddin(2) XOR ddin(3);
	aux(3)<= ddin(3) XOR ddin(4);
	aux(4)<= ddin(4) XOR ddin(5);
	m0in<= ddin(0) & ddin(1) & ddin(2) & ddin(3) & ddin(4) & ddin(5);
	m1in<= ddin(1) & ddin(2) & ddin(3) & ddin(4) & ddin(5) & aux(0);
	m2in<= ddin(2) & ddin(3) & ddin(4) & ddin(5) & aux(0) & aux(1);
	m3in<= ddin(3) & ddin(4) & ddin(5) & aux(0) & aux(1) & aux(2);
	m4in<= ddin(4) & ddin(5) & aux(0) & aux(1) & aux(2) & aux(3);
	m5in<= ddin(5) & aux(0) & aux(1) & aux(2) & aux(3) & aux(4);
	m0:  dsdbm
		PORT MAP (m0in, dsin, dout(0));
	m1:  dsdbm
		PORT MAP (m1in, dsin, dout(1));
	m2:  dsdbm
		PORT MAP (m2in, dsin, dout(2));
	m3:  dsdbm
		PORT MAP (m3in, dsin, dout(3));
	m4:  dsdbm
		PORT MAP (m4in, dsin, dout(4));
	m5:  dsdbm
		PORT MAP (m5in, dsin, dout(5));

END dpdbma; 

-------------------------------------------------------------------
-- Bit-Parallel Multiplier 

	USE WORK.const.ALL;
ENTITY dpm IS
PORT (din1, din2: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1));  
END dpm;

ARCHITECTURE dpma OF dpm IS
	COMPONENT dsdbm -- Serial Dual Basis Multiplier without registers
	  PORT (dbin, sbin: IN BIT_VECTOR(0 TO m-1); 
	  	  -- dual & standard basis in
		dout: OUT BIT); 
	  END COMPONENT;
	  FOR ALL: dsdbm USE ENTITY WORK.dsdbm (dsdbma);

	SIGNAL b: BIT_VECTOR(0 TO 10);
	SIGNAL c0, c1, c2, c3, c4, c5: BIT_VECTOR(0 TO m-1);
  BEGIN
	b(0 TO m-1)<= din1;
	b(6)<= b(0) XOR b(5);
	b(7)<= b(5) XOR b(4);
	b(8)<= b(4) XOR b(3);
	b(9)<= b(3) XOR b(2);
	b(10)<= b(2) XOR b(1);
	c0<= b(0) & b(5) & b(4) & b(3) & b(2) & b(1);
	m0: dsdbm
		PORT MAP (din2, c0, dout(0));
	c1<= b(1) & b(6) & b(7) & b(8) & b(9) & b(10);
	m1: dsdbm
		PORT MAP (din2, c1, dout(1));
	c2<= b(2) & b(1) & b(6) & b(7) & b(8) & b(9);
	m2: dsdbm
		PORT MAP (din2, c2, dout(2));
	c3<= b(3) & b(2) & b(1) & b(6) & b(7) & b(8);
	m3: dsdbm
		PORT MAP (din2, c3, dout(3));
	c4<= b(4) & b(3) & b(2) & b(1) & b(6) & b(7);
	m4: dsdbm
		PORT MAP (din2, c4, dout(4));
	c5<= b(5) & b(4) & b(3) & b(2) & b(1) & b(6);
	m5: dsdbm
		PORT MAP (din2, c5, dout(5));

END dpma;

----------------------------------------------------------------------------------
-- Bit-Serial Standard Basis Multiplier for syn*c=dr module2 - ring

	USE WORK.const.ALL;
ENTITY dssbm IS
PORT (clk, ce, pe : IN BIT;
	din: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1)); 
END dssbm;

ARCHITECTURE dssbma OF dssbm IS
	SIGNAL ring: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= ring;
  PROCESS BEGIN
      WAIT UNTIL clk'EVENT AND clk='1';
      IF pe='1' THEN 
	ring<= din;
      ELSIF ce='1' THEN
	ring(0)<= din(0) XOR (NOT pe AND ring(m-1));
	ring(1)<= din(1) XOR (NOT pe AND (ring(m-1) XOR ring(0)));
	ring(2)<= din(2) XOR (NOT pe AND ring(1));
	ring(3)<= din(3) XOR (NOT pe AND ring(2));
	ring(4)<= din(4) XOR (NOT pe AND ring(3));
	ring(5)<= din(5) XOR (NOT pe AND ring(4));
      END IF;
  END PROCESS;
END dssbma;	

-------------------------------------------------------------------
-- sum t* XOR - dout= din(0) xor din(1) .... xor din(t)

	USE WORK.const.ALL;
ENTITY dxort IS
PORT (din0, din1, din2, din3: IN BIT;
	dout: OUT BIT);
END dxort;

ARCHITECTURE dxorta OF dxort IS
  BEGIN
	dout<= din0 XOR din1 XOR din2 XOR din3;
END dxorta;


--------------------------------------------------------------------

-- Multiply by L^i, where gen. polynomial = 1+ x^i + x^m (for m!=8)

	USE WORK.const.ALL;
ENTITY dmli IS
PORT (din: IN BIT_VECTOR(0 TO m-1);
 	dout: OUT BIT_VECTOR(0 TO m-1));
END dmli;

ARCHITECTURE dmlia OF dmli IS
BEGIN
	dout(0)<= din(1);
	dout(1)<= din(2);
	dout(2)<= din(3);
	dout(3)<= din(4);
	dout(4)<= din(5);
	dout(5)<= din(0) XOR din(1);
END dmlia;

---------------------------------------------------------------------------
-- squaring dout<= (din)^2 in standard basis -- for inverse calculator

	USE WORK.const.ALL;
ENTITY dsq IS
PORT ( din: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1)); -- serial output 
END dsq;

ARCHITECTURE dsqa OF dsq IS
	SIGNAL dxor: BIT_VECTOR(0 TO 5);
  BEGIN
	dxor(0 TO m-1)<= din;
		-- optimization saving = 0 XOR gates
	dout(0)<= dxor(0) XOR dxor(3);
	dout(1)<= dxor(3);
	dout(2)<= dxor(1) XOR dxor(4);
	dout(3)<= dxor(4);
	dout(4)<= dxor(2) XOR dxor(5);
	dout(5)<= dxor(5);
	-- no. XOR gates = 3
 
END dsqa;

-----------------------------------------------------------------------------
-- m* registers with reset to dual basis one

	USE WORK.const.ALL;
ENTITY drdrDualOne IS
PORT (clk, ce, reset: BIT;
	din: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1)); -- serial output 
END drdrDualOne;

ARCHITECTURE drdrDualOnea OF drdrDualOne IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF reset='1' THEN
		q<= "100000";
	ELSIF ce='1' THEN
		q<= din;
	ELSE 
		q<= q;
	END IF;
  END PROCESS;
END drdrDualOnea;

----------------------------------------------------------------------------------
-- Inverter dout<= din^(-1)<= din^(2)*din^(4)*...*din^(2^(m-1))

	USE WORK.const.ALL;
ENTITY dinv IS
PORT (clk, cbBeg, bsel, caLast, cce, drnzero, snce, synpe: IN BIT;  
	din: IN BIT_VECTOR(0 TO m-1); --input data selected by sel_in
	dout: OUT BIT_VECTOR(0 TO m-1));
END dinv;

ARCHITECTURE dinva OF dinv IS
	SIGNAL qsq, sq, msin, mdin, mout: BIT_VECTOR(0 TO m-1);
	-- sq- square, q??- RD out, m??? - parallel multiplier, ?d/s -dual standard basis
	SIGNAL ce1, ce2a, ce2b, ce2, reset, sel: BIT;
	
	COMPONENT dmul21   -- 2-1 multiplexer
	  	PORT ( sel: IN BIT; d0, d1: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
	  	FOR ALL: dmul21 USE ENTITY WORK.dmul21 (dmul21a);
	COMPONENT drdce     -- PIPO register
	  	PORT (clk, ce: IN BIT; din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1));  
		END COMPONENT;
	  	FOR ALL: drdce USE ENTITY WORK.drdce (drdcea);
	COMPONENT drdrDualOne -- registers with and reset to dual basis one
		PORT (clk, ce, reset: IN BIT; din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
	  	FOR ALL: drdrDualOne USE ENTITY WORK.drdrDualOne (drdrDualOnea);
	COMPONENT dsq    -- dout<= (din)^2
	  	PORT ( din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsq USE ENTITY WORK.dsq (dsqa);
	COMPONENT dpdbm    -- Parallel dual basis multiplier
		PORT (ddin, dsin: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1));  
		END COMPONENT;
	  	FOR ALL: dpdbm USE ENTITY WORK.dpdbm (dpdbma);
  BEGIN
	ce1<= ce2 OR caLast OR synpe;
	ce2a<= drnzero AND cbBeg;
	ce2b<= bsel OR ce2a;
	ce2<= cce AND NOT snce AND ce2b;
	reset<= (snce AND bsel) OR synpe;
	sel<= caLast OR synpe;

	dout<= mout;
	x1: dmul21
	  PORT MAP (sel, qsq, din, msin);
	s1: dsq
	  PORT MAP (msin, sq);
	q1: drdce  
	  PORT MAP (clk, ce1, sq, qsq);
	q2: drdrDualOne
	  PORT MAP (clk, ce2, reset, mout, mdin);
	m1: dpdbm
	  PORT MAP (mdin, msin, mout);
END dinva;

---------------------------------------------------------------------------------
-- Find if chien search circuit is equal 0

	USE WORK.const.ALL;
ENTITY dcheq IS
PORT (din0, din1, din2, din3: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT); -- dout=1 if equal 
END dcheq;

ARCHITECTURE dcheqa OF dcheq IS
	SIGNAL eq: BIT_VECTOR(0 TO m-1);
  BEGIN
	eq(0)<= din0(0) XOR din1(0) XOR din2(0) XOR din3(0);
	eq(1)<= din0(1) XOR din1(1) XOR din2(1) XOR din3(1);
	eq(2)<= din0(2) XOR din1(2) XOR din2(2) XOR din3(2);
	eq(3)<= din0(3) XOR din1(3) XOR din2(3) XOR din3(3);
	eq(4)<= din0(4) XOR din1(4) XOR din2(4) XOR din3(4);
	eq(5)<= din0(5) XOR din1(5) XOR din2(5) XOR din3(5);
	dout<= NOT (eq(0) OR eq(1) OR eq(2) OR eq(3) OR eq(4) OR eq(5));
END dcheqa;

----------------------------------------------------------------------------------
---------------------------------------------------------------------------
-- Syndromes calculation circuits

	USE WORK.const.ALL;
ENTITY dsyn1 IS
PORT (clk, pe ,din: IN BIT;
	dout1, dout2, dout4: OUT BIT_VECTOR(0 TO m-1));
END dsyn1;

ARCHITECTURE dsyn1a OF dsyn1 IS
	SIGNAL syn: BIT_VECTOR(0 TO 8);
  BEGIN
	syn(6)<= syn(2) XOR syn(5); -- 2
	syn(7)<= syn(0) XOR syn(3); -- 1
	syn(8)<= syn(1) XOR syn(4); -- 1
		-- Saving due to optimization = 4
	dout1(0 TO m-1)<= syn(0 TO m-1);
	dout2(0)<= syn(7);
	dout2(1)<= syn(3);
	dout2(2)<= syn(8);
	dout2(3)<= syn(4);
	dout2(4)<= syn(6);
	dout2(5)<= syn(5);
	dout4(0)<= syn(4) XOR syn(7);
	dout4(1)<= syn(4);
	dout4(2)<= syn(3) XOR syn(6);
	dout4(3)<= syn(6);
	dout4(4)<= syn(5) XOR syn(8);
	dout4(5)<= syn(5);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 5)<= "00000";
	ELSE
	  syn(0)<= syn(5) XOR din;
	  syn(1)<= syn(0) XOR syn(5);
	  syn(2)<= syn(1);
	  syn(3)<= syn(2);
	  syn(4)<= syn(3);
	  syn(5)<= syn(4);
	END IF;
  END PROCESS;
END dsyn1a;


	USE WORK.const.ALL;
ENTITY dsyn3 IS
PORT (clk, pe ,din: IN BIT;
	dout3: OUT BIT_VECTOR(0 TO m-1));
END dsyn3;

ARCHITECTURE dsyn3a OF dsyn3 IS
	SIGNAL syn: BIT_VECTOR(0 TO 5);
  BEGIN
	dout3<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 5)<= "00000";
	ELSE
	syn(0)<= din XOR syn(3);
	syn(1)<= syn(3) XOR syn(4);
	syn(2)<= syn(4) XOR syn(5);
	syn(3)<= syn(0) XOR syn(5);
	syn(4)<= syn(1);
	syn(5)<= syn(2);
	END IF;
  END PROCESS;
END dsyn3a;


	USE WORK.const.ALL;
ENTITY dsyn5 IS
PORT (clk, pe ,din: IN BIT;
	dout5: OUT BIT_VECTOR(0 TO m-1));
END dsyn5;

ARCHITECTURE dsyn5a OF dsyn5 IS
	SIGNAL syn: BIT_VECTOR(0 TO 5);
  BEGIN
	dout5<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 5)<= "00000";
	ELSE
	syn(0)<= din XOR syn(1);
	syn(1)<= syn(1) XOR syn(2);
	syn(2)<= syn(2) XOR syn(3);
	syn(3)<= syn(3) XOR syn(4);
	syn(4)<= syn(4) XOR syn(5);
	syn(5)<= syn(0) XOR syn(5);
	END IF;
  END PROCESS;
END dsyn5a;


---------------------------------------------------------------------------
-- Chien search circuits

	USE WORK.const.ALL;
ENTITY dch1 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch1;

ARCHITECTURE dch1a OF dch1 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 5); -- ch registers and optimization 
  BEGIN
	dout<= ch(0 TO m-1);
	chin(0)<= ch(5);
	chin(1)<= ch(0) XOR ch(5);
	chin(2)<= ch(1);
	chin(3)<= ch(2);
	chin(4)<= ch(3);
	chin(5)<= ch(4);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 1;
END dch1a;


	USE WORK.const.ALL;
ENTITY dch2 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch2;

ARCHITECTURE dch2a OF dch2 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 5); -- ch registers and optimization 
  BEGIN
	dout<= ch(0 TO m-1);
	chin(0)<= ch(4);
	chin(1)<= ch(4) XOR ch(5);
	chin(2)<= ch(0) XOR ch(5);
	chin(3)<= ch(1);
	chin(4)<= ch(2);
	chin(5)<= ch(3);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 2;
END dch2a;


	USE WORK.const.ALL;
ENTITY dch3 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch3;

ARCHITECTURE dch3a OF dch3 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 5); -- ch registers and optimization 
  BEGIN
	dout<= ch(0 TO m-1);
	chin(0)<= ch(3);
	chin(1)<= ch(3) XOR ch(4);
	chin(2)<= ch(4) XOR ch(5);
	chin(3)<= ch(0) XOR ch(5);
	chin(4)<= ch(1);
	chin(5)<= ch(2);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 3;
END dch3a;


-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- CONTROL ENTITIES - counters
-- counter a

	USE WORK.const.ALL;
ENTITY dca IS
PORT (clk, reset: IN BIT;
	cRes: OUT BIT; -- cRes<= countLast OR  reset
	dout: OUT BIT_VECTOR(0 TO sizea-1)); -- count
END dca;

ARCHITECTURE dcaa OF dca IS
	SIGNAL ca, cin, cand: BIT_VECTOR(0 TO sizea-1);
	SIGNAL CRes1, cLast: BIT;
  BEGIN
	dout<= ca;
	cRes<= cRes1;
	cRes1<= cLast OR reset;
	cLast<= NOT ca(0) AND ca(1);  -- ca= 2
		--cLast=1 - when c= iteration-1
	cand(0)<= ca(0);
	cin(0)<= NOT ca(0);

	   gen_cin:
	FOR i IN 1 TO sizea-1 GENERATE
		cin(i)<= cand(i-1) XOR ca(i);
	END GENERATE;
	  den_cand_if:
	IF sizea>2 GENERATE
	  gen_cand:
	  FOR i IN 1 TO sizea-2 GENERATE
		cand(i)<= ca(i) AND cand(i-1);
	  END GENERATE;
	END GENERATE;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	FOR i IN 0 TO sizea-1 LOOP
	  IF cRes1='1' THEN
        	ca(i)<= '0';	
	  ELSE
		ca(i)<= cin(i);
	  END IF;
	END LOOP;
  END PROCESS;
END dcaa;

------------------------------------------------------------------------------
-- counter b -- no. of cicles count= iteration*cb +ca 

	USE WORK.const.ALL;
ENTITY dcb IS
PORT (clk, ce, reset: IN BIT;
	dout: OUT BIT_VECTOR(0 TO sizeb-1)); -- count
END dcb;

ARCHITECTURE dcba OF dcb IS
	SIGNAL cb, cin, cand: BIT_VECTOR(0 TO sizeb-1);
  BEGIN
	dout<= cb;
	cand(0)<= cb(0);
	cin(0)<= NOT cb(0);

	   gen_cin:
	FOR i IN 1 TO sizeb-1 GENERATE
		cin(i)<= cand(i-1) XOR cb(i);
	END GENERATE;
		gen_cand:
	FOR i IN 1 TO sizeb-2 GENERATE
		cand(i)<= cb(i) AND cand(i-1);
	END GENERATE;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	FOR i IN 0 TO sizeb-1 LOOP
	  IF reset='1' THEN
        	cb(i)<= '0';	
	  ELSIF ce='1' THEN
		cb(i)<= cin(i);
	  END IF;
	END LOOP;
  END PROCESS;
END dcba;
-------------------------------------------------------------------------------
-- l (degree of error polynomial in BMA) circuit  

	USE WORK.const.ALL;
ENTITY dcl IS
PORT (clk, ce, reset, bsel: IN BIT;
	cb: BIT_VECTOR(0 TO sizeb-1);
	dout: OUT BIT); -- dout=1 if l<= cb
END dcl;

ARCHITECTURE dcla OF dcl IS
	SIGNAL l, lin, lcarry, lxor, lcomp: BIT_VECTOR(0 TO sizel-1);
	SIGNAL lce: BIT;
  BEGIN
	dout<= lcomp(sizel-1);
	-- compare --> lcomp(sizel-1)<= (cb>=l)
	lcomp(0)<= NOT l(0) OR cb(0);
	gencomp:
	FOR i IN 1 TO sizel-1 GENERATE
	  lcomp(i)<= (lcomp(i-1) AND (NOT l(i) OR cb(i)))  OR  (NOT l(i) AND cb(i));
	END GENERATE;
		
	-- register l subtractor; lin<= 2*cb-l+1 <=> { lin<=2*cb+2+NOT(l) }
	lin(0)<= NOT l(0);
	lin(1) <= cb(0) XOR l(1);
	lcarry(1)<= cb(0) OR NOT l(1);
	      genl:
	FOR i IN 2 TO sizel-1 GENERATE
		lxor(i)<= cb(i-1) XOR NOT l(i);
		lin(i)<= lxor(i) XOR lcarry(i-1);
		lcarry(i)<= (NOT l(i) AND cb(i-1)) OR (lxor(i) AND lcarry(i-1));
	END GENERATE;
	lce<= ce AND bsel;
  PROCESS BEGIN  
	WAIT UNTIL clk'EVENT AND clk='1';
	-- l register 
	IF reset='1' THEN
		l(0)<= bsel;   -- if Syn1=0 l<= 0, else l<=1
	ELSIF lce='1' THEN
		l(0)<= lin(0);
	END IF;

	FOR i IN 1 TO sizel-1 LOOP
	  IF reset='1' THEN
		l(i)<= '0';
	  ELSIF lce='1' THEN
		l(i)<= lin(i);
	  END IF;
	END LOOP;
  END PROCESS;
END dcla;

-------------------------------------------------------------------------------	
-- control system and counter

	USE WORK.const.ALL;
ENTITY dcount IS
PORT (clk, reset, drnzero: IN BIT;
	bsel, bufCe, bufkCe, chpe, msmpe, snce, synpe, vdout, vdout1: OUT BIT);
		-- vdout - delayed by one clock vdout11
END dcount;

ARCHITECTURE dcounta OF dcount IS
	COMPONENT drd1ce -- single register with clock enable
		PORT ( clk, ce, din: IN BIT; dout: OUT BIT);
		END COMPONENT; 
	  	FOR ALL: drd1ce USE ENTITY WORK.drd1ce (drd1cea);
	COMPONENT dca  -- counter a
		PORT (clk, reset: IN BIT; cRes: OUT BIT;
		dout: OUT BIT_VECTOR(0 TO sizea-1));	
		END COMPONENT; 
	  	FOR ALL: dca USE ENTITY WORK.dca (dcaa);
	COMPONENT dcb  -- counter b
		PORT (clk, ce, reset: IN BIT;
		dout: OUT BIT_VECTOR(0 TO sizeb-1));	
		END COMPONENT; 
	  	FOR ALL: dcb USE ENTITY WORK.dcb (dcba);
	COMPONENT dcl -- l (degree of error polynomial in BMA) circuit  
		PORT (clk, ce, reset, bsel: IN BIT; -- dout=1 if l<= cb
		cb: BIT_VECTOR(0 TO sizeb-1); dout: OUT BIT); 
		END COMPONENT; 
	  	FOR ALL: dcL USE ENTITY WORK.dcL (dcLa);

	-- VHDL Template
	SIGNAL ca: BIT_VECTOR(0 TO sizea-1); -- counter a
	SIGNAL cb: BIT_VECTOR(0 TO sizeb-1); --  count= ca+ iteration*cb
	SIGNAL res, bsel1, caRes, bufR, bufRa, bufRb, bufS, bufSa, bufSb, bufSR: BIT; 
	SIGNAL chpe1, chpe1a, chpe1b, synpe1,  msmpe1, cei1: BIT;
	-- cei - interleave clock enable
	SIGNAL vdout11, vdout11a, vdout1R, vdout1Ra, vdout1Rb: BIT;
	SIGNAL vdout1S, vdout1Sa, vdout1Sb: BIT;
	SIGNAL ca0, caLast,caNextLast, cb0, cLast, cLasta, cLastb, lCe, lcomp: BIT;
	SIGNAL bufkCeCe, one, vdout11Ce, vdout11In, bufCe1, bufkCe1: BIT;
	SIGNAL noFirstVdoutIn, noFirstVdout, vdout11aDel: BIT;
  BEGIN
	res<= reset OR clast;
	a1: dca
		PORT MAP (clk, res, caLast, ca);
	b1: dcb
		PORT MAP (clk, caLast, res, cb);
	l1: dcl
		PORT MAP (clk, lCe, synpe1, bsel1, cb, lcomp); -- lcomp=1 if cb>=l
	bufkCeCe<= res OR bufR;
	bufk_Ce: drd1ce  -- buffer Clock Enable register
		PORT MAP (clk, bufkCeCe, res, bufkCe1);
	bufkCe<= bufkCe1 AND cei1;

	one<= '1'; 
	vDoutD: drd1ce -- delay vdout by one clock signal: vdout11
		PORT MAP (clk, one, vdout11, vdout);
	vdout11Ce<= reset OR vdout1R OR vdout1S;
	vdout11In<= vdout1S AND NOT reset;
	vdout11P: drd1ce  -- set if vdout1S; reset if reset or vdout1R
		PORT MAP (clk, vdout11Ce, vdout11In, vdout11a);	
	-- After reset the first vdout11a is not valid
	vdout1aDelay: drd1ce
		PORT MAP (clk, one, vdout11a, vdout11aDel); 
	noFirstVdoutIn<= NOT reset AND ((NOT vdout11a AND vdout11aDel) OR noFirstVdout); 
		-- falling edge of vdout1a - set; reset - reset
	noFirstAfterReset: drd1ce
		PORT MAP (clk, one, noFirstVdoutIn, noFirstVdout); 

	vdout11<= vdout11a AND cei1 AND noFirstVdout;

	snce<= ca0;
	chpe<= chpe1;
	synpe<= synpe1;
	synpe1<= ca0 AND cb0;
	vdout1<= vdout11;
	msmpe<= msmpe1;
	bsel<= bsel1;
	bsel1<= drnzero AND (lcomp OR synpe1);

	-- generated by C program
	clastb<= NOT cb(0) AND NOT cb(1) AND cb(2) AND NOT cb(3) AND cb(4);  -- cb= 20
	clasta<= NOT ca(0) AND ca(1);  -- ca= 2
	clast<= clasta AND clastb; -- count= 62
	chpe1b<= NOT cb(0) AND cb(1) AND NOT cb(2) AND NOT cb(3) AND NOT cb(4);  -- cb= 2
	chpe1a<= ca(0) AND NOT ca(1);  -- ca= 1
	chpe1<= chpe1a AND chpe1b; -- count= 7
	vdout1Rb<= cb(0) AND NOT cb(1) AND NOT cb(2) AND NOT cb(3) AND cb(4);  -- cb= 17
	vdout1Ra<= NOT ca(0) AND ca(1);  -- ca= 2
	vdout1R<= vdout1Ra AND vdout1Rb; -- count= 53
	vdout1Sb<= NOT cb(0) AND cb(1) AND NOT cb(2) AND NOT cb(3) AND NOT cb(4);  -- cb= 2
	vdout1Sa<= NOT ca(0) AND ca(1);  -- ca= 2
	vdout1S<= vdout1Sa AND vdout1Sb; -- count= 8
	bufRb<= NOT cb(0) AND cb(1) AND cb(2) AND cb(3) AND NOT cb(4);  -- cb= 14
	bufRa<= NOT ca(0) AND ca(1);  -- ca= 2
	bufR<= bufRa AND bufRb; -- count= 44
	cb0<= NOT cb(0) AND NOT cb(1) AND NOT cb(2) AND NOT cb(3) AND NOT cb(4);  -- cb= 0
	lCe<= ca0;
	msmpe1<= NOT ca(0) AND ca(1);  -- ca= 2
	ca0<= NOT ca(0) AND NOT ca(1);  -- ca= 0
	caNextLast<= ca(0) AND NOT ca(1);  -- ca= 1
	bufCe<= '1';
	cei1<= '1';
END dcounta;	


------------------------------------------------------------------------------
----------------------------------------------------------------------------------
-- decoder

	USE WORK.const.ALL;
ENTITY dec IS
PORT (clk, reset, din: IN BIT;
	vdout, dout: OUT BIT);
END dec;

ARCHITECTURE deca OF dec IS

	COMPONENT dbuf   -- input output buffer
		PORT (clk, bufCe, bufkCe, err, vdout1, din: IN BIT;
			dout: OUT BIT);
		END COMPONENT; 
	  	FOR ALL: dbuf USE ENTITY WORK.dbuf (dbufa);
	COMPONENT drd1ce -- single register with clock enable
		PORT ( clk, ce, din: IN BIT; dout: OUT BIT);
		END COMPONENT; 
--	  	FOR ALL: drd1ce USE ENTITY WORK.drd1ce (drd1cea);
	COMPONENT dmul21 
		PORT ( sel: IN BIT; d0, d1: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1));  
		END COMPONENT; 
	  	FOR ALL: dmul21 USE ENTITY WORK.dmul21 (dmul21a);
	COMPONENT drd     -- PIPO register
	  	PORT (clk: IN BIT; din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1));  
		END COMPONENT;
--	  	FOR ALL: drd USE ENTITY WORK.drd (drda);
	COMPONENT drdce   -- PIPO register
	  	PORT (clk, ce: IN BIT; din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1));  
		END COMPONENT;
	  	FOR ALL: drdce USE ENTITY WORK.drdce (drdcea);
	COMPONENT drdcer   -- PIPO register
	  	PORT (clk, ce, reset: IN BIT; din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1));  
		END COMPONENT;
	  	FOR ALL: drdcer USE ENTITY WORK.drdcer (drdcera);
	COMPONENT drdcesone   -- m registers with CE and if set='1' dout<=din0&"00.." 
		PORT ( clk, ce, set, dinone: IN BIT; din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
	  	FOR ALL: drdcesone USE ENTITY WORK.drdcesone (drdcesonea);
	COMPONENT dpm    -- Parallel dual basis multiplier
		PORT (din1, din2: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1));  
		END COMPONENT;
	  	FOR ALL: dpm USE ENTITY WORK.dpm (dpma);
	COMPONENT dxorm            -- dout<= din1 xor din0; opt.1
		PORT (din0, din1: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
	  	FOR ALL: dxorm USE ENTITY WORK.dxorm (dxorma);


		-- OPTION 3
	COMPONENT dshr   -- shift register with reset and serial XOR, opt.3
		PORT (clk, ce, reset, din: IN BIT;
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
--	  	FOR ALL: dshr USE ENTITY WORK.dshr (dshra);
	COMPONENT dshpe   -- shift register with parallel in and serial XOR, opt.3
		PORT (clk, ce, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
--	  	FOR ALL: dshpe USE ENTITY WORK.dshpe (dshpea);
	COMPONENT dsdbm -- serial dual basis multiplier without ring, opt.3
		PORT (dbin, sbin: IN BIT_VECTOR(0 TO m-1); dout: OUT BIT);
		END COMPONENT;
--	  	FOR ALL: dsdbm USE ENTITY WORK.dsdbm (dsdbma);
	COMPONENT  dsdbmRing  -- serial dual basis multiplier ring, opt.3
		PORT (clk, pe: IN BIT;   -- pe- parallel enable
			din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
--	  	FOR ALL: dsdbmRing USE ENTITY WORK.dsdbmRing (dsdbmRinga);
	COMPONENT dssbm   -- serial standard basis multiplier ring, opt3
		PORT (clk, ce, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
--	  	FOR ALL: dssbm USE ENTITY WORK.dssbm (dssbma);
	COMPONENT dmli  -- multiply by alpha^i (1 + x^i + x^m; for m!=8), opt.3
		PORT (din: IN BIT_VECTOR(0 TO m-1);
 			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
--	  	FOR ALL: dmli USE ENTITY WORK.dmli (dmlia);
	COMPONENT dinv  -- inverter
		PORT (clk, cbBeg, bsel, caLast, cce, drnzero, snce, synpe: IN BIT;  -- pe- parallel enable - if dr!=0; 
			din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
--	  	FOR ALL: dinv USE ENTITY WORK.dinv (dinva);
	COMPONENT dandm  -- dout<= din AND en
		PORT (en: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
		dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
--	  	FOR ALL: dandm USE ENTITY WORK.dandm (dandma);
	
		-- common
	COMPONENT dxort                       -- (t-1) * XOR
		PORT (din0, din1, din2, din3: IN BIT; dout: OUT BIT);
		END COMPONENT;
	  	FOR ALL: dxort USE ENTITY WORK.dxort (dxorta);
	COMPONENT dcheq   -- check if Chien search circuit is zero
		PORT (din0, din1, din2, din3: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT); -- dout=1 if an error occur
		END COMPONENT;
	  	FOR ALL: dcheq USE ENTITY WORK.dcheq (dcheqa);

	-- SYNDROMES & CHIEN SEARCH
	COMPONENT dsyn1
		PORT (clk, pe, din: IN BIT;
		dout1, dout2, dout4: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
 		FOR ALL: dsyn1 USE ENTITY WORK.dsyn1 (dsyn1a);
	COMPONENT dsyn3
		PORT (clk, pe, din: IN BIT;
		dout3: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
 		FOR ALL: dsyn3 USE ENTITY WORK.dsyn3 (dsyn3a);
	COMPONENT dsyn5
		PORT (clk, pe, din: IN BIT;
		dout5: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
 		FOR ALL: dsyn5 USE ENTITY WORK.dsyn5 (dsyn5a);
	COMPONENT dch1
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch1 USE ENTITY WORK.dch1 (dch1a);
	COMPONENT dch2
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch2 USE ENTITY WORK.dch2 (dch2a);
	COMPONENT dch3
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch3 USE ENTITY WORK.dch3 (dch3a);

	-- common signals generated by C program
	SIGNAL syn1, syn2, syn3, syn4, syn5: BIT_VECTOR(0 TO m-1);
	SIGNAL sn0out, sn1out, sn2out, sn3out, sn4out: BIT_VECTOR(0 TO m-1);
	SIGNAL sn0in, sn1in, sn2in, sn3in: BIT_VECTOR(0 TO m-1);
	SIGNAL c0out, c1out, c2out, c3out: BIT_VECTOR(0 TO m-1);
	SIGNAL b2out, b3out: BIT_VECTOR(0 TO m-1);
	SIGNAL ch0out, ch1out, ch2out, ch3out: BIT_VECTOR(0 TO m-1);

	-- for different option by C program
	SIGNAL m0out, m1out, m2out, m3out: BIT_VECTOR(0 TO m-1);
	SIGNAL c1in, c2in, c3in: BIT_VECTOR(0 TO m-1);
	SIGNAL mb2out, mb3out: BIT_VECTOR(0 TO m-1);
	SIGNAL mc0out, mc1out, mc2out, mc3out: BIT_VECTOR(0 TO m-1);
	SIGNAL b2in, b3in: BIT_VECTOR(0 TO m-1);

	--  option 2 VHDL template
	SIGNAL  chpe, msmPe, snce, synpe, vdout1: BIT; 
		-- from counter - control signals
	SIGNAL cs, dr, drnzero: BIT_VECTOR(0 TO m-1);
	SIGNAL err, bsel, bufCe, bufkCe, b23set, b2s, b3s: BIT;  
		-- bsel=1 - Br+1<- Br*x^2
	SIGNAL one: BIT;
	SIGNAL dp, qdpin, xc1in: BIT_VECTOR(0 TO m-1);
	SIGNAL qdpce, qdpset: BIT;

	COMPONENT dcount --counter
		PORT (clk, reset, drnzero: IN BIT;
		bsel, bufCe, bufkCe, chpe, msmpe, snce, synpe, vdout, vdout1: OUT BIT);
		END COMPONENT; 
	  	FOR ALL: dcount USE ENTITY WORK.dcount (dcounta);
 
  BEGIN
	xqdp: dmul21
		PORT MAP (synpe, dr, syn1, qdpin);
	qdpce<= bsel AND snce;
	qdpset<= synpe AND NOT drnzero(m-1);
	qdp: drdcesone
		PORT MAP (clk, qdpce, qdpset, one, qdpin, dp);
	count: dcount
		PORT MAP (clk, reset, drnzero(m-1), bsel, bufCe, bufkCe, chpe, msmpe, snce, synpe, vdout, vdout1);
	msm: drdce
		PORT MAP (clk, msmpe, cs, dr);
	c0: drdcesone
		PORT MAP (clk, snce, synpe, one, mc0out, c0out);
	ch0: drdce
		PORT MAP (clk, chpe, c0out, ch0out);
	c1: drdce
		PORT MAP (clk, snce, c1in, c1out);
	xc1: dmul21
		PORT MAP (synpe, mc1out, syn1, c1in);
	drnzero(0)<= qdpin(0);
	gen_drnzero:
	FOR i IN 1 TO m-1 GENERATE
		drnzero(i)<= drnzero(i-1) OR qdpin(i);
	END GENERATE;
	b23set<= synpe OR (snce AND NOT bsel);
	b2s<= synpe AND drnzero(m-1);
	b2: drdcesone
		PORT MAP (clk, snce, b23set, b2s, c0out, b2out);
	b3s<= synpe AND NOT drnzero(m-1);
	b3:  drdcesone
		PORT MAP (clk, snce, b23set, b3s, c1out, b3out);


	--------- for option 2 C program 
	ms0: dxort
		PORT MAP (m0out(0), m1out(0), m2out(0), m3out(0), cs(0));
	ms1: dxort
		PORT MAP (m0out(1), m1out(1), m2out(1), m3out(1), cs(1));
	ms2: dxort
		PORT MAP (m0out(2), m1out(2), m2out(2), m3out(2), cs(2));
	ms3: dxort
		PORT MAP (m0out(3), m1out(3), m2out(3), m3out(3), cs(3));
	ms4: dxort
		PORT MAP (m0out(4), m1out(4), m2out(4), m3out(4), cs(4));
	ms5: dxort
		PORT MAP (m0out(5), m1out(5), m2out(5), m3out(5), cs(5));
	m0: dpm
		PORT MAP (c0out, sn0out, m0out);
	m1: dpm
		PORT MAP (c1out, sn1out, m1out);
	m2: dpm
		PORT MAP (c2out, sn2out, m2out);
	m3: dpm
		PORT MAP (c3out, sn3out, m3out);
	c2: drdcer
		PORT MAP (clk, snce, synpe, c2in, c2out);
	c3: drdcer
		PORT MAP (clk, snce, synpe, c3in, c3out);
	cs2: dxorm
		PORT MAP (mb2out, mc2out, c2in);
	cs3: dxorm
		PORT MAP (mb3out, mc3out, c3in);
	mc0: dpm
		PORT MAP (c0out, dp, mc0out);
	mc1: dpm
		PORT MAP (c1out, dp, mc1out);
	mc2: dpm
		PORT MAP (c2out, dp, mc2out);
	mc3: dpm
		PORT MAP (c3out, dp, mc3out);
	mb2: dpm
		PORT MAP (b2out, dr, mb2out);
	mb3: dpm
		PORT MAP (b3out, dr, mb3out);

	--------- common C program
	s1: dsyn1
		PORT MAP (clk, synpe, din,  syn1, syn2, syn4);
	s3: dsyn3
		PORT MAP (clk, synpe, din,  syn3);
	s5: dsyn5
		PORT MAP (clk, synpe, din,  syn5);
	x0: dmul21
		PORT MAP (synpe, sn3out, syn3, sn0in);
	x1: dmul21
		PORT MAP (synpe, sn4out, syn2, sn1in);
	x2: dmul21
		PORT MAP (synpe, sn0out, syn1, sn2in);
	x3: dmul21
		PORT MAP (synpe, sn1out, syn5, sn3in);
	sn0: drdce
		PORT MAP (clk, snce, sn0in, sn0out);
	sn1: drdce
		PORT MAP (clk, snce, sn1in, sn1out);
	sn2: drdce
		PORT MAP (clk, snce, sn2in, sn2out);
	sn3: drdce
		PORT MAP (clk, snce, sn3in, sn3out);
	sn4: drdce
		PORT MAP (clk, synpe, syn4, sn4out);
	ch1: dch1
		PORT MAP (clk, chpe, c1out, ch1out);
	ch2: dch2
		PORT MAP (clk, chpe, c2out, ch2out);
	ch3: dch3
		PORT MAP (clk, chpe, c3out, ch3out);
	cheg: dcheq
		PORT MAP (ch0out, ch1out, ch2out, ch3out,  err);

	--- common for all option VHDL template 
	one<= '1';
	buf: dbuf
		PORT MAP (clk, bufCe, bufkCe, err, vdout1, din, dout);
END deca;
