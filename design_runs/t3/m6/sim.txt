
Help text file for bch.exe program that generate binary (n,k) BCH code.

bch.exe program uses following input files:
bch.in - to specify input parameters of BCH code, only this file 
	should be changed (if the bch.exe cannot find bch.in file then
	it requests the user to type BCH code and program parameters
bch.vht - data needed to generate enc.vhd and sim.vhd and sim.txt files
bch1.vht - data needed to generate dec.vhd if t (no. of errors) = 1
bch2.vht - data needed to generate dec.vhd if t = 2
bch3.vht - data needed to generate dec.vhd if t > 2
bchs.vht - data needed to generate sym.cmd and sym.cme

bch.exe generates (overwrites !!!) following files:
const.vhd - VHDL package file that contains useful constants
enc.vhd - VHDL file for generating BCH code encoder
dec.vhd - VHDL file for generating BCH code decoder
sim.vhd - VHDL file for generating file for simulation encoder and decoder
sim.cmd - command file for simulation before synthesis
sim.cme - command file for simulation after synthesis

bch.in file should consists of following:
m= xx - specify width of Galois Field GF(2^m), n=2^m-1
t= xx - specify number of errors to be may corrected
program option (placed in bch.in):
-oxx - for t>2 circuit option;
	xx = 2 - parallel architecture
	xx = 3 - serial architecture - preferred.
-sxx - generate sym.cmd and sym.cme with specified 
	by xx simulation time (number of codewords to simulate)
	xx=0 - do not generate simulation command files.
-ix - xx - interleave number. The frequency of Berlekamp-Massey 
	Algorithm in comparison to data transfer (syndrome calculation) frequency.
	f_BMA = interleave * f_syn
-mxx - design optimization by extracting
	xx= 0 -  without optimisation
	xx= 1,2... - with optimization - introduce a new intermediate
		signal only if it reduces the number of XOR at least by xx



There are following BCH codes for m= 6 and t<=3. (n,k,t)
(63, 57, 1) 	(63, 51, 2) 	(63, 45, 3) 	



	---------------- ENCODER----------------

ering - LFSR Linear Feedback Shift Registers
		Reg= 18		XOR= 9
ecount - counter (control system)
		Reg= 7		XOR= 1
ENCODER --
		Reg= 1		XOR= 0
	total	Reg= 26		XOR= 10




	-------------- DECODER ---------------

--------------- Syndromes calculation ------------
dsyn1 - syndromes  1 2 4
		Reg= 6		XOR= 8
dsyn3 - syndromes  3
		Reg= 6		XOR= 4
dsyn5 - syndromes  5
		Reg= 6		XOR= 6
	total	Reg= 18		XOR= 18

--------------- Chien Search ------------
dcheq - check if Chien search equal zero - found an error
		Reg= 0		XOR= 12
dch1 - Chien Search for x^1
		Reg= 6		XOR= 1
dch2 - Chien Search for x^2
		Reg= 6		XOR= 2
dch3 - Chien Search for x^3
		Reg= 6		XOR= 3
	total	Reg= 18		XOR= 18

--------------- Syndromes rearranging ------------
dmul21 - 2 to 1 multiplexers 
		Reg= 0 * 4 = 0	XOR= 0 * 4 = 0
drdce - m registers with clock enable
		Reg= 6 * 5 = 30	XOR= 0 * 5 = 0
	total	Reg= 30		XOR= 0

--------------- Berlekamp-Massey Algorithm ----
dmul21 - 2 to 1 multiplexers
dmli - multiply by L^i
		Reg= 0		XOR= 1
dinv - inversion/division
		Reg= 12		XOR= 38
dsdbmRing - bit-Serial Dual Basis Multiplier Ring
		Reg= 6		XOR= 1
drdce - m registers with clock enable
		Reg= 6		XOR= 0
drdceSOne - m registers with set to one
		Reg= 6 * 2 = 12	XOR= 0 * 2 = 0
drd1ce - single register with clock enable
		Reg= 1 * 2 = 2	XOR= 0 * 2 = 0
dsdbm - bit-serial dual basis multiplier
		Reg= 0		XOR= 5
dshpe - m shift registers (ring) with parallel enable
		Reg= 6		XOR= 0
dshr - m shift registers (ring) with reset and addition
		Reg= 6 * 2 = 12	XOR= 1 * 2 = 2
dandm - m AND gates
		Reg= 0 * 4 = 0	XOR= 0 * 4 = 0
dxort - t XOR gates
		Reg= 0 * 6 = 0	XOR= 3 * 6 = 18
dssbm - bit-serial standard basis multiplier
		Reg= 6		XOR= 7
	total	Reg= 56		XOR= 72

--------------- The buffer  ----
dbuf - buffer for storing data to be corrected
		Reg= 70		XOR= 1
	total	Reg= 70		XOR= 1

--------------- The control system  ----
dca - less signficant control counter
		Reg= 3		XOR= 2
dcb - more signficant control counter
		Reg= 3		XOR= 2
dcl - degree of error polynomial
		Reg= 3		XOR= 3
drd1ce - single register
		Reg= 1 * 5 = 5	XOR= 0 * 5 = 0
dcount - control system
	total	Reg= 14		XOR= 7


	DECODER total
		Reg= 206		XOR= 116



GF(2^6) generated by polynomial: 1 + x^1 + x^6
  no.  Standard    Dual basis
   -   000000     000000
   0   100000     100000
   1   010000     000001
   2   001000     000010
   3   000100     000100
   4   000010     001000
   5   000001     010000
   6   110000     100001
   7   011000     000011
   8   001100     000110
   9   000110     001100
  10   000011     011000
  11   110001     110001
  12   101000     100010
  13   010100     000101
  14   001010     001010
  15   000101     010100
  16   110010     101001
  17   011001     010011
  18   111100     100111
  19   011110     001111
  20   001111     011110
  21   110111     111101
  22   101011     111010
  23   100101     110100
  24   100010     101000
  25   010001     010001
  26   111000     100011
  27   011100     000111
  28   001110     001110
  29   000111     011100
  30   110011     111001
  31   101001     110010
  32   100100     100100
  33   010010     001001
  34   001001     010010
  35   110100     100101
  36   011010     001011
  37   001101     010110
  38   110110     101101
  39   011011     011011
  40   111101     110111
  41   101110     101110
  42   010111     011101
  43   111011     111011
  44   101101     110110
  45   100110     101100
  46   010011     011001
  47   111001     110011
  48   101100     100110
  49   010110     001101
  50   001011     011010
  51   110101     110101
  52   101010     101010
  53   010101     010101
  54   111010     101011
  55   011101     010111
  56   111110     101111
  57   011111     011111
  58   111111     111111
  59   101111     111110
  60   100111     111100
  61   100011     111000
  62   100001     110000
  63   100000     100000