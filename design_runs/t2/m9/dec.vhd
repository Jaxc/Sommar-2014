-- File generated by bch.exe program.
-- The decoder for BCH code (511,493), t=2
 -- with optimization= 1.
-- GF(2^9) is generated by polynomial [1+x+...] - 1000100001;
-------------------------------------------------------------------

ENTITY ffce IS
PORT (clk, ce, din: IN BIT; -- ce- clock enable
	dout: OUT BIT); --output serial data
END ffce;

ARCHITECTURE ffcea OF ffce IS
	SIGNAL q: BIT;
  BEGIN
	dout<= q;
  PROCESS BEGIN 
	WAIT UNTIL clk'EVENT AND clk='1';
	IF ce='1' THEN
	  q<= din;
	ELSE
	  q<= q;
	END IF;
  END PROCESS;
END ffcea;	

-------------------------------------------------------------------
-- counter modulo n

	USE WORK.const.ALL;
ENTITY dcount IS
PORT (clk, reset: IN BIT; 
	cef, pe, vdout, vdout1: OUT BIT);
END dcount;

ARCHITECTURE dcounta OF dcount IS	
	SIGNAL cout: BIT_VECTOR(0 TO m-1);
	SIGNAL vdout11, vdoutS, vdoutR, nFirst, cef1: BIT;
  BEGIN
	pe<=  cout(0) AND NOT cout(1) AND NOT cout(2) AND NOT cout(3) AND NOT cout(4) AND NOT cout(5) AND NOT cout(6) AND NOT cout(7) AND NOT cout(8);
		-- pe=1 if count=0
	cef1<=  NOT cout(0) AND cout(1) AND NOT cout(2) AND NOT cout(3) AND NOT cout(4) AND NOT cout(5) AND NOT cout(6) AND NOT cout(7) AND NOT cout(8);
		-- cef=1 if count= 1;
	cef<= cef1;
	vdoutS<= nFirst AND cef1;
		-- vdout=1 if count=1
	vdoutR<= reset OR ( cout(0) AND cout(1) AND NOT cout(2) AND cout(3) AND cout(4) AND NOT cout(5) AND NOT cout(6) AND NOT cout(7) AND cout(8));
		-- vdout=1 if count=k+1
	vdout1<= vdout11;

  PROCESS BEGIN -- increment or reset cout in ring, cout=L^count
	WAIT UNTIL clk'EVENT AND clk='1';
	IF reset='1' THEN
		nFirst<= '0';
	ELSIF vdoutR='1' THEN
		nFirst<= '1';
	END IF;

	IF vdoutR='1' THEN
		vdout11<= '0';
	ELSIF vdoutS='1' THEN
		vdout11<= '1';
	END IF;
	vdout<= vdout11; -- delay by one clock

	cout(0)<= cout(m-1) OR reset;
	cout(1)<= cout(0) AND NOT reset;
	cout(2)<= cout(1) AND NOT reset;
	cout(3)<= cout(2) AND NOT reset;
	cout(4)<= (cout(3) XOR cout(m-1)) AND NOT reset;
	cout(5)<= cout(4) AND NOT reset;
	cout(6)<= cout(5) AND NOT reset;
	cout(7)<= cout(6) AND NOT reset;
	cout(8)<= cout(7) AND NOT reset;
  END PROCESS;
END dcounta;

---------------------------------------------------------------------
-- buffer circuit
	library IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.numeric_STD.all;
USE WORK.const.ALL;
ENTITY dbuf IS
PORT (clk, err, vdout, din: IN BIT;
dout: OUT BIT);
END dbuf;
ARCHITECTURE dbufa OF dbuf IS
CONSTANT zero_vec : BIT_VECTOR(0 to n-1) := (others => '0');
SIGNAL buf,dout_buf,dout_buf2 : BIT_VECTOR(0 to n);
signal reg_ena : BIT_VECTOR(0 to n):= '1' & zero_vec;
signal dout_buf3 : BIT;

component bufcount
PORT(clk: in BIT; count : OUT STD_LOGIC_VECTOR(m-1 downto 0));
end component;
BEGIN
	registers:for i in 0 to n generate
	
		buf2_gen1:if i /= 0 generate	
			dout_buf2(i) <= dout_buf(i) or dout_buf2(i-1);
		end generate;

		process(clk,buf,reg_ena)
		begin
			if ( clk'EVENT AND clk='1') then
				if reg_ena(i) = '1' then
					buf(i) <= din;
				end if;				
			end if;
			dout_buf(i) <= buf(i) and reg_ena(i);
		end process;

	end generate;
dout_buf2(0) <= dout_buf(0);
PROCESS (clk)
	BEGIN
	if ( clk'EVENT AND clk='1') then
		dout_buf3 <= dout_buf2(n);
		dout <= (dout_buf3 XOR err) and vdout;
		reg_ena(1 to n) <= reg_ena(0 to n-1);
		reg_ena(0) <= reg_ena(n);
	end if;
end process;

END dbufa;
---------------------------------------------------------------------------
-- Syndromes calculation circuits

	USE WORK.const.ALL;
ENTITY dsyn1 IS
PORT (clk, pe ,din: IN BIT;
	dout1: OUT BIT_VECTOR(0 TO m-1));
END dsyn1;

ARCHITECTURE dsyn1a OF dsyn1 IS
	SIGNAL syn: BIT_VECTOR(0 TO 8);
  BEGIN
	dout1<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 8)<= "00000000";
	ELSE
	syn(0)<= din XOR syn(8);
	syn(1)<= syn(0);
	syn(2)<= syn(1);
	syn(3)<= syn(2);
	syn(4)<= syn(3) XOR syn(8);
	syn(5)<= syn(4);
	syn(6)<= syn(5);
	syn(7)<= syn(6);
	syn(8)<= syn(7);
	END IF;
  END PROCESS;
END dsyn1a;


	USE WORK.const.ALL;
ENTITY dsyn3 IS
PORT (clk, pe ,din: IN BIT;
	dout3: OUT BIT_VECTOR(0 TO m-1));
END dsyn3;

ARCHITECTURE dsyn3a OF dsyn3 IS
	SIGNAL syn: BIT_VECTOR(0 TO 8);
  BEGIN
	dout3<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 8)<= "00000000";
	ELSE
	syn(0)<= din XOR syn(6);
	syn(1)<= syn(7);
	syn(2)<= syn(8);
	syn(3)<= syn(0);
	syn(4)<= syn(1) XOR syn(6);
	syn(5)<= syn(2) XOR syn(7);
	syn(6)<= syn(3) XOR syn(8);
	syn(7)<= syn(4);
	syn(8)<= syn(5);
	END IF;
  END PROCESS;
END dsyn3a;



-----------------------------------------------------------------
-- dout<= din^3

	USE WORK.const.ALL;
ENTITY dpow3 IS
PORT (din: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1));
END dpow3;

ARCHITECTURE dpow3a OF dpow3 IS
	SIGNAL dxor: BIT_VECTOR(0 TO 73);
  BEGIN
	dxor(0 TO m-1)<= din;
	dxor(9)<= din(0) AND din(1);
	dxor(10)<= din(0) AND din(2);
	dxor(11)<= din(0) AND din(3);
	dxor(12)<= din(0) AND din(4);
	dxor(13)<= din(0) AND din(5);
	dxor(14)<= din(0) AND din(6);
	dxor(15)<= din(0) AND din(7);
	dxor(16)<= din(0) AND din(8);
	dxor(17)<= din(1) AND din(2);
	dxor(18)<= din(1) AND din(3);
	dxor(19)<= din(1) AND din(4);
	dxor(20)<= din(1) AND din(5);
	dxor(21)<= din(1) AND din(6);
	dxor(22)<= din(1) AND din(7);
	dxor(23)<= din(1) AND din(8);
	dxor(24)<= din(2) AND din(3);
	dxor(25)<= din(2) AND din(4);
	dxor(26)<= din(2) AND din(5);
	dxor(27)<= din(2) AND din(6);
	dxor(28)<= din(2) AND din(7);
	dxor(29)<= din(2) AND din(8);
	dxor(30)<= din(3) AND din(4);
	dxor(31)<= din(3) AND din(5);
	dxor(32)<= din(3) AND din(6);
	dxor(33)<= din(3) AND din(7);
	dxor(34)<= din(3) AND din(8);
	dxor(35)<= din(4) AND din(5);
	dxor(36)<= din(4) AND din(6);
	dxor(37)<= din(4) AND din(7);
	dxor(38)<= din(4) AND din(8);
	dxor(39)<= din(5) AND din(6);
	dxor(40)<= din(5) AND din(7);
	dxor(41)<= din(5) AND din(8);
	dxor(42)<= din(6) AND din(7);
	dxor(43)<= din(6) AND din(8);
	dxor(44)<= din(7) AND din(8);
	dxor(45)<= dxor(8) XOR dxor(22); -- 3
	dxor(46)<= dxor(15) XOR dxor(36); -- 3
	dxor(47)<= dxor(23) XOR dxor(32); -- 3
	dxor(48)<= dxor(26) XOR dxor(40); -- 3
	dxor(49)<= dxor(39) XOR dxor(41); -- 3
	dxor(50)<= dxor(43) XOR dxor(47); -- 3
	dxor(51)<= dxor(5) XOR dxor(30); -- 2
	dxor(52)<= dxor(7) XOR dxor(49); -- 2
	dxor(53)<= dxor(16) XOR dxor(20); -- 2
	dxor(54)<= dxor(19) XOR dxor(45); -- 2
	dxor(55)<= dxor(25) XOR dxor(37); -- 2
	dxor(56)<= dxor(29) XOR dxor(44); -- 2
	dxor(57)<= dxor(33) XOR dxor(48); -- 2
	dxor(58)<= dxor(38) XOR dxor(50); -- 2
	dxor(59)<= dxor(42) XOR dxor(46); -- 2
	dxor(60)<= dxor(3) XOR dxor(27); -- 1
	dxor(61)<= dxor(4) XOR dxor(14); -- 1
	dxor(62)<= dxor(6) XOR dxor(35); -- 1
	dxor(63)<= dxor(10) XOR dxor(31); -- 1
	dxor(64)<= dxor(11) XOR dxor(52); -- 1
	dxor(65)<= dxor(17) XOR dxor(59); -- 1
	dxor(66)<= dxor(18) XOR dxor(58); -- 1
	dxor(67)<= dxor(24) XOR dxor(56); -- 1
	dxor(68)<= dxor(34) XOR dxor(51); -- 1
	dxor(69)<= dxor(36) XOR dxor(53); -- 1
	dxor(70)<= dxor(37) XOR dxor(54); -- 1
	dxor(71)<= dxor(40) XOR dxor(55); -- 1
	dxor(72)<= dxor(43) XOR dxor(63); -- 1
	dxor(73)<= dxor(57) XOR dxor(61); -- 1
		-- optimization saving = 50 XOR gates
	dout(0)<= dxor(0) XOR dxor(29) XOR dxor(41) XOR dxor(48) XOR dxor(59) XOR dxor(60) XOR dxor(62) XOR dxor(70);
	dout(1)<= dxor(9) XOR dxor(13) XOR dxor(22) XOR dxor(27) XOR dxor(58) XOR dxor(68) XOR dxor(71);
	dout(2)<= dxor(9) XOR dxor(30) XOR dxor(42) XOR dxor(52) XOR dxor(69) XOR dxor(72);
	dout(3)<= dxor(1) XOR dxor(50) XOR dxor(56) XOR dxor(64) XOR dxor(73);
	dout(4)<= dxor(12) XOR dxor(21) XOR dxor(54) XOR dxor(57) XOR dxor(60) XOR dxor(65) XOR dxor(72);
	dout(5)<= dxor(35) XOR dxor(44) XOR dxor(45) XOR dxor(55) XOR dxor(65) XOR dxor(66) XOR dxor(68);
	dout(6)<= dxor(2) XOR dxor(14) XOR dxor(31) XOR dxor(32) XOR dxor(38) XOR dxor(51) XOR dxor(64) XOR dxor(69) XOR dxor(70);
	dout(7)<= dxor(28) XOR dxor(46) XOR dxor(53) XOR dxor(66) XOR dxor(67) XOR dxor(73);
	dout(8)<= dxor(12) XOR dxor(16) XOR dxor(23) XOR dxor(31) XOR dxor(49) XOR dxor(62) XOR dxor(67) XOR dxor(71);
		-- 83 XOR gates
	
END dpow3a;

---------------------------------------------------------------------------
-- compare if equal = dout<= ((syn1)^3 == syn3) 

	USE WORK.const.ALL;
ENTITY deq IS
PORT (syn1, syn3: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT);
END deq;

ARCHITECTURE deqa OF deq IS
	SIGNAL neq_or: BIT_VECTOR(0 TO m-1);
	SIGNAL power: BIT_VECTOR(0 TO m-1); -- power =(syn1)^3	
		-- power 3 circuit
	COMPONENT dpow3 -- dout<= din^3
		PORT (din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
		FOR ALL: dpow3 USE ENTITY WORK.dpow3 (dpow3a);
  BEGIN
	p1: dpow3
		PORT MAP(syn1, power);
	dout<= neq_or(m-1);
	neq_or(0)<= syn3(0) XOR power(0);
	gen:
	FOR i IN 1 TO m-1 GENERATE
		neq_or(i)<= neq_or(i-1) OR (syn3(i) XOR power(i)); 
	END GENERATE;	
END deqa;

---------------------------------------------------------------------------
-- Chien search circuit

	USE WORK.const.ALL;
ENTITY dch1 IS
PORT (clk, err, errcheck, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch1;

ARCHITECTURE dch1a OF dch1 IS
	SIGNAL ch0reg: BIT;
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 8); -- ch registers and optimization 
  BEGIN
	ch0reg<= ch(0) XOR err; -- error was found so correct it
	dout(0)<= ch(0) XOR errcheck; -- suppose that an error has occured
	dout(1 TO m-1)<= ch(1 TO m-1);
	chin(0)<= ch(8);
	chin(1)<= ch0reg;
	chin(2)<= ch(1);
	chin(3)<= ch(2);
	chin(4)<= ch(3) XOR ch(8);
	chin(5)<= ch(4);
	chin(6)<= ch(5);
	chin(7)<= ch(6);
	chin(8)<= ch(7);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 1;
END dch1a;


	USE WORK.const.ALL;
ENTITY dch3 IS
PORT (clk, err, errcheck, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch3;

ARCHITECTURE dch3a OF dch3 IS
	SIGNAL ch0reg: BIT;
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 8); -- ch registers and optimization 
  BEGIN
	ch0reg<= ch(0) XOR err; -- error was found so correct it
	dout(0)<= ch(0) XOR errcheck; -- suppose that an error has occured
	dout(1 TO m-1)<= ch(1 TO m-1);
	chin(0)<= ch(6);
	chin(1)<= ch(7);
	chin(2)<= ch(8);
	chin(3)<= ch0reg;
	chin(4)<= ch(1) XOR ch(6);
	chin(5)<= ch(2) XOR ch(7);
	chin(6)<= ch(3) XOR ch(8);
	chin(7)<= ch(4);
	chin(8)<= ch(5);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 3;
END dch3a;


---------------------------------------------------------------------------
-- decoder circuit
	USE WORK.const.ALL;
ENTITY dec IS
PORT (clk, reset, din: IN BIT; 
	vdout, dout: OUT BIT); 
END dec;

ARCHITECTURE deca OF dec IS
	SIGNAL  pe, cef, cefa, vdout1, din_reset: BIT;
	--pe -parallel enable sr->sc;  er - correct error,
	--vdout - valid data out - remember data register 
	SIGNAL ff1, ff3, err, err1, err2, errcheck, ce, neq: BIT; 
	SIGNAL syn1, syn3: BIT_VECTOR(0 TO m-1); -- syndromes
	SIGNAL ch1, ch3: BIT_VECTOR(0 TO m-1); -- Chien output
	SIGNAL ch1_or: BIT_VECTOR(0 TO m-1);

	COMPONENT deq -- dout<= ( syn1^3 != syn3 )
		PORT (syn1, syn3: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT); 
		END COMPONENT;
		FOR ALL: deq USE ENTITY WORK.deq (deqa);
	COMPONENT ffce  
		PORT (clk, ce, din: IN BIT; 
			dout: OUT BIT); 
		END COMPONENT;
		FOR ALL: ffce USE ENTITY WORK.ffce (ffcea);
	COMPONENT dcount -- counter decoder 
		PORT(clk, reset: IN BIT; cef, pe, vdout, vdout1: OUT BIT); 
		END COMPONENT;
		FOR ALL: dcount USE ENTITY WORK.dcount (dcounta);
	COMPONENT dbuf -- buffer shift registers 
		PORT (clk, err, vdout, din: IN BIT; 
			dout: OUT BIT); 
		END COMPONENT;
		FOR ALL: dbuf USE ENTITY WORK.dbuf (dbufa);
	COMPONENT dsyn1 -- syndrome calculation 
		PORT (clk, pe, din: IN BIT; 
			dout1: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
		FOR ALL: dsyn1 USE ENTITY WORK.dsyn1 (dsyn1a);
	COMPONENT dsyn3 -- syndrome calculation 
		PORT (clk, pe, din: IN BIT; 
			dout3: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
		FOR ALL: dsyn3 USE ENTITY WORK.dsyn3 (dsyn3a);
	COMPONENT dch1 -- Chien's search circuit 
		PORT (clk, err, errcheck, pe: IN BIT;
			 din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
		FOR ALL: dch1 USE ENTITY WORK.dch1 (dch1a);
	COMPONENT dch3 -- Chien's search circuit 
		PORT (clk, err, errcheck, pe: IN BIT;
			 din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
		FOR ALL: dch3 USE ENTITY WORK.dch3 (dch3a);

  BEGIN
	c1: dcount
		PORT MAP (clk, reset, cef, pe, vdout, vdout1);
	b1: dbuf
		PORT MAP (clk, err, vdout1, din_reset, dout);
	e1: deq
		PORT MAP (ch1, ch3, neq);
	f1: ffce
		PORT MAP (clk, cefa, ch1_or(m-1), ff1);
	f2: ffce
		PORT MAP (clk, cefa, neq, ff3);
	s1: dsyn1
		PORT MAP (clk, pe, din_reset, syn1); 
	s3: dsyn3
		PORT MAP (clk, pe, din_reset, syn3); 
	h1: dch1
		PORT MAP (clk, err, errcheck, pe, syn1, ch1); 
	h3: dch3
		PORT MAP (clk, err, errcheck, pe, syn3, ch3); 


	din_reset<= din AND NOT reset;

	--  ch1_or eq_or gates
	ch1_or(0)<= ch1(0);
	gen:
	FOR i IN 1 TO m-1 GENERATE
		ch1_or(i)<= ch1_or(i-1) OR ch1(i);
	END GENERATE;	

	-- cefa - clock enable p1, p3 - cepa=1 if start of a new word or err
	cefa <= cef OR err; 
	-- error decision circuit
	err1<= NOT ff3 AND  NOT neq AND ff1 AND NOT ch1_or(m-1); 
		--single err
	err2<= ff1 AND ch1_or(m-1) AND ff3 AND NOT neq; 
		-- double error
	err<= err1 OR err2; -- error has been found
	errcheck<= NOT cef; -- 
END deca;
