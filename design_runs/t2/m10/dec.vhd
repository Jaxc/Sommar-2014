-- File generated by bch.exe program.
-- The decoder for BCH code (1023,1003), t=2
 -- with optimization= 1.
-- GF(2^10) is generated by polynomial [1+x+...] - 10010000001;
-------------------------------------------------------------------

ENTITY ffce IS
PORT (clk, ce, din: IN BIT; -- ce- clock enable
	dout: OUT BIT); --output serial data
END ffce;

ARCHITECTURE ffcea OF ffce IS
	SIGNAL q: BIT;
  BEGIN
	dout<= q;
  PROCESS BEGIN 
	WAIT UNTIL clk'EVENT AND clk='1';
	IF ce='1' THEN
	  q<= din;
	ELSE
	  q<= q;
	END IF;
  END PROCESS;
END ffcea;	

-------------------------------------------------------------------
-- counter modulo n

	USE WORK.const.ALL;
ENTITY dcount IS
PORT (clk, reset: IN BIT; 
	cef, pe, vdout, vdout1: OUT BIT);
END dcount;

ARCHITECTURE dcounta OF dcount IS	
	SIGNAL cout: BIT_VECTOR(0 TO m-1);
	SIGNAL vdout11, vdoutS, vdoutR, nFirst, cef1: BIT;
  BEGIN
	pe<=  cout(0) AND NOT cout(1) AND NOT cout(2) AND NOT cout(3) AND NOT cout(4) AND NOT cout(5) AND NOT cout(6) AND NOT cout(7) AND NOT cout(8) AND NOT cout(9);
		-- pe=1 if count=0
	cef1<=  NOT cout(0) AND cout(1) AND NOT cout(2) AND NOT cout(3) AND NOT cout(4) AND NOT cout(5) AND NOT cout(6) AND NOT cout(7) AND NOT cout(8) AND NOT cout(9);
		-- cef=1 if count= 1;
	cef<= cef1;
	vdoutS<= nFirst AND cef1;
		-- vdout=1 if count=1
	vdoutR<= reset OR ( NOT cout(0) AND cout(1) AND cout(2) AND cout(3) AND NOT cout(4) AND NOT cout(5) AND cout(6) AND cout(7) AND NOT cout(8) AND cout(9));
		-- vdout=1 if count=k+1
	vdout1<= vdout11;

  PROCESS BEGIN -- increment or reset cout in ring, cout=L^count
	WAIT UNTIL clk'EVENT AND clk='1';
	IF reset='1' THEN
		nFirst<= '0';
	ELSIF vdoutR='1' THEN
		nFirst<= '1';
	END IF;

	IF vdoutR='1' THEN
		vdout11<= '0';
	ELSIF vdoutS='1' THEN
		vdout11<= '1';
	END IF;
	vdout<= vdout11; -- delay by one clock

	cout(0)<= cout(m-1) OR reset;
	cout(1)<= cout(0) AND NOT reset;
	cout(2)<= cout(1) AND NOT reset;
	cout(3)<= (cout(2) XOR cout(m-1)) AND NOT reset;
	cout(4)<= cout(3) AND NOT reset;
	cout(5)<= cout(4) AND NOT reset;
	cout(6)<= cout(5) AND NOT reset;
	cout(7)<= cout(6) AND NOT reset;
	cout(8)<= cout(7) AND NOT reset;
	cout(9)<= cout(8) AND NOT reset;
  END PROCESS;
END dcounta;

---------------------------------------------------------------------
-- buffer circuit
	library IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.numeric_STD.all;
USE WORK.const.ALL;
ENTITY dbuf IS
PORT (clk, err, vdout, din: IN BIT;
dout: OUT BIT);
END dbuf;
ARCHITECTURE dbufa OF dbuf IS
SIGNAL buf: BIT_VECTOR(0 TO n);
SIGNAL cnt,last_cnt : integer range 0 to n+2;
SIGNAL dout_buf,dout_buf2 : BIT;
SIGNAL reg_ena,last_reg_ena : BIT_VECTOR(0 to n);
component bufcount
PORT(clk: in BIT; count : OUT STD_LOGIC_VECTOR(m-1 downto 0));
end component;
BEGIN
process(cnt)
begin
reg_ena <= (others => '0');
reg_ena(cnt) <= '1';
end process;
registers:for i in 0 to n generate
	process(clk)
		begin
		if last_reg_ena(i) = '1' then
			buf(i) <= din;
		end if;
	end process;
end generate;

PROCESS (clk)
	BEGIN
	if ( clk'EVENT AND clk='1') then
		dout_buf2 <= buf(cnt);
		dout_buf <= dout_buf2;
		dout <= (dout_buf XOR err) and vdout;
		last_reg_ena <= reg_ena;
		if cnt = n then
			cnt <= 0;
		else
			cnt <= cnt +1;
		end if;
		last_cnt <= cnt;

	end if;
end process;

END dbufa;
---------------------------------------------------------------------------
-- Syndromes calculation circuits

	USE WORK.const.ALL;
ENTITY dsyn1 IS
PORT (clk, pe ,din: IN BIT;
	dout1: OUT BIT_VECTOR(0 TO m-1));
END dsyn1;

ARCHITECTURE dsyn1a OF dsyn1 IS
	SIGNAL syn: BIT_VECTOR(0 TO 9);
  BEGIN
	dout1<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 9)<= "000000000";
	ELSE
	syn(0)<= din XOR syn(9);
	syn(1)<= syn(0);
	syn(2)<= syn(1);
	syn(3)<= syn(2) XOR syn(9);
	syn(4)<= syn(3);
	syn(5)<= syn(4);
	syn(6)<= syn(5);
	syn(7)<= syn(6);
	syn(8)<= syn(7);
	syn(9)<= syn(8);
	END IF;
  END PROCESS;
END dsyn1a;


	USE WORK.const.ALL;
ENTITY dsyn3 IS
PORT (clk, pe ,din: IN BIT;
	dout3: OUT BIT_VECTOR(0 TO m-1));
END dsyn3;

ARCHITECTURE dsyn3a OF dsyn3 IS
	SIGNAL syn: BIT_VECTOR(0 TO 9);
  BEGIN
	dout3<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 9)<= "000000000";
	ELSE
	syn(0)<= din XOR syn(7);
	syn(1)<= syn(8);
	syn(2)<= syn(9);
	syn(3)<= syn(0) XOR syn(7);
	syn(4)<= syn(1) XOR syn(8);
	syn(5)<= syn(2) XOR syn(9);
	syn(6)<= syn(3);
	syn(7)<= syn(4);
	syn(8)<= syn(5);
	syn(9)<= syn(6);
	END IF;
  END PROCESS;
END dsyn3a;



-----------------------------------------------------------------
-- dout<= din^3

	USE WORK.const.ALL;
ENTITY dpow3 IS
PORT (din: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT_VECTOR(0 TO m-1));
END dpow3;

ARCHITECTURE dpow3a OF dpow3 IS
	SIGNAL dxor: BIT_VECTOR(0 TO 91);
  BEGIN
	dxor(0 TO m-1)<= din;
	dxor(10)<= din(0) AND din(1);
	dxor(11)<= din(0) AND din(2);
	dxor(12)<= din(0) AND din(3);
	dxor(13)<= din(0) AND din(4);
	dxor(14)<= din(0) AND din(5);
	dxor(15)<= din(0) AND din(6);
	dxor(16)<= din(0) AND din(7);
	dxor(17)<= din(0) AND din(8);
	dxor(18)<= din(0) AND din(9);
	dxor(19)<= din(1) AND din(2);
	dxor(20)<= din(1) AND din(3);
	dxor(21)<= din(1) AND din(4);
	dxor(22)<= din(1) AND din(5);
	dxor(23)<= din(1) AND din(6);
	dxor(24)<= din(1) AND din(7);
	dxor(25)<= din(1) AND din(8);
	dxor(26)<= din(1) AND din(9);
	dxor(27)<= din(2) AND din(3);
	dxor(28)<= din(2) AND din(4);
	dxor(29)<= din(2) AND din(5);
	dxor(30)<= din(2) AND din(6);
	dxor(31)<= din(2) AND din(7);
	dxor(32)<= din(2) AND din(8);
	dxor(33)<= din(2) AND din(9);
	dxor(34)<= din(3) AND din(4);
	dxor(35)<= din(3) AND din(5);
	dxor(36)<= din(3) AND din(6);
	dxor(37)<= din(3) AND din(7);
	dxor(38)<= din(3) AND din(8);
	dxor(39)<= din(3) AND din(9);
	dxor(40)<= din(4) AND din(5);
	dxor(41)<= din(4) AND din(6);
	dxor(42)<= din(4) AND din(7);
	dxor(43)<= din(4) AND din(8);
	dxor(44)<= din(4) AND din(9);
	dxor(45)<= din(5) AND din(6);
	dxor(46)<= din(5) AND din(7);
	dxor(47)<= din(5) AND din(8);
	dxor(48)<= din(5) AND din(9);
	dxor(49)<= din(6) AND din(7);
	dxor(50)<= din(6) AND din(8);
	dxor(51)<= din(6) AND din(9);
	dxor(52)<= din(7) AND din(8);
	dxor(53)<= din(7) AND din(9);
	dxor(54)<= din(8) AND din(9);
	dxor(55)<= dxor(26) XOR dxor(32); -- 3
	dxor(56)<= dxor(30) XOR dxor(51); -- 3
	dxor(57)<= dxor(38) XOR dxor(46); -- 3
	dxor(58)<= dxor(6) XOR dxor(18); -- 2
	dxor(59)<= dxor(8) XOR dxor(34); -- 2
	dxor(60)<= dxor(9) XOR dxor(40); -- 2
	dxor(61)<= dxor(15) XOR dxor(49); -- 2
	dxor(62)<= dxor(28) XOR dxor(44); -- 2
	dxor(63)<= dxor(29) XOR dxor(57); -- 2
	dxor(64)<= dxor(31) XOR dxor(35); -- 2
	dxor(65)<= dxor(37) XOR dxor(45); -- 2
	dxor(66)<= dxor(42) XOR dxor(53); -- 2
	dxor(67)<= dxor(54) XOR dxor(55); -- 2
	dxor(68)<= dxor(56) XOR dxor(59); -- 2
	dxor(69)<= dxor(4) XOR dxor(48); -- 1
	dxor(70)<= dxor(5) XOR dxor(24); -- 1
	dxor(71)<= dxor(7) XOR dxor(22); -- 1
	dxor(72)<= dxor(10) XOR dxor(67); -- 1
	dxor(73)<= dxor(12) XOR dxor(23); -- 1
	dxor(74)<= dxor(13) XOR dxor(47); -- 1
	dxor(75)<= dxor(14) XOR dxor(33); -- 1
	dxor(76)<= dxor(17) XOR dxor(21); -- 1
	dxor(77)<= dxor(19) XOR dxor(66); -- 1
	dxor(78)<= dxor(20) XOR dxor(39); -- 1
	dxor(79)<= dxor(36) XOR dxor(50); -- 1
	dxor(80)<= dxor(39) XOR dxor(58); -- 1
	dxor(81)<= dxor(41) XOR dxor(60); -- 1
	dxor(82)<= dxor(43) XOR dxor(49); -- 1
	dxor(83)<= dxor(45) XOR dxor(52); -- 1
	dxor(84)<= dxor(46) XOR dxor(62); -- 1
	dxor(85)<= dxor(50) XOR dxor(65); -- 1
	dxor(86)<= dxor(52) XOR dxor(79); -- 1
	dxor(87)<= dxor(53) XOR dxor(83); -- 1
	dxor(88)<= dxor(61) XOR dxor(63); -- 1
	dxor(89)<= dxor(68) XOR dxor(75); -- 1
	dxor(90)<= dxor(69) XOR dxor(88); -- 1
	dxor(91)<= dxor(84) XOR dxor(89); -- 1
		-- optimization saving = 54 XOR gates
	dout(0)<= dxor(0) XOR dxor(82) XOR dxor(85) XOR dxor(91);
	dout(1)<= dxor(34) XOR dxor(51) XOR dxor(64) XOR dxor(66) XOR dxor(71) XOR dxor(72) XOR dxor(80);
	dout(2)<= dxor(11) XOR dxor(44) XOR dxor(72) XOR dxor(86) XOR dxor(90);
	dout(3)<= dxor(1) XOR dxor(35) XOR dxor(48) XOR dxor(60) XOR dxor(73) XOR dxor(87) XOR dxor(91);
	dout(4)<= dxor(11) XOR dxor(16) XOR dxor(22) XOR dxor(38) XOR dxor(40) XOR dxor(41) XOR dxor(58) XOR dxor(64) XOR dxor(67) XOR dxor(68) XOR dxor(74) XOR dxor(77);
	dout(5)<= dxor(14) XOR dxor(55) XOR dxor(70) XOR dxor(77) XOR dxor(78) XOR dxor(90);
	dout(6)<= dxor(2) XOR dxor(54) XOR dxor(61) XOR dxor(64) XOR dxor(73) XOR dxor(76) XOR dxor(81) XOR dxor(85);
	dout(7)<= dxor(25) XOR dxor(27) XOR dxor(44) XOR dxor(47) XOR dxor(56) XOR dxor(57) XOR dxor(65) XOR dxor(71) XOR dxor(78) XOR dxor(81);
	dout(8)<= dxor(17) XOR dxor(23) XOR dxor(27) XOR dxor(32) XOR dxor(62) XOR dxor(70) XOR dxor(74) XOR dxor(80) XOR dxor(86);
	dout(9)<= dxor(3) XOR dxor(18) XOR dxor(24) XOR dxor(26) XOR dxor(31) XOR dxor(41) XOR dxor(63) XOR dxor(76) XOR dxor(82) XOR dxor(87);
		-- 105 XOR gates
	
END dpow3a;

---------------------------------------------------------------------------
-- compare if equal = dout<= ((syn1)^3 == syn3) 

	USE WORK.const.ALL;
ENTITY deq IS
PORT (syn1, syn3: IN BIT_VECTOR(0 TO m-1); 
	dout: OUT BIT);
END deq;

ARCHITECTURE deqa OF deq IS
	SIGNAL neq_or: BIT_VECTOR(0 TO m-1);
	SIGNAL power: BIT_VECTOR(0 TO m-1); -- power =(syn1)^3	
		-- power 3 circuit
	COMPONENT dpow3 -- dout<= din^3
		PORT (din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
		FOR ALL: dpow3 USE ENTITY WORK.dpow3 (dpow3a);
  BEGIN
	p1: dpow3
		PORT MAP(syn1, power);
	dout<= neq_or(m-1);
	neq_or(0)<= syn3(0) XOR power(0);
	gen:
	FOR i IN 1 TO m-1 GENERATE
		neq_or(i)<= neq_or(i-1) OR (syn3(i) XOR power(i)); 
	END GENERATE;	
END deqa;

---------------------------------------------------------------------------
-- Chien search circuit

	USE WORK.const.ALL;
ENTITY dch1 IS
PORT (clk, err, errcheck, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch1;

ARCHITECTURE dch1a OF dch1 IS
	SIGNAL ch0reg: BIT;
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 9); -- ch registers and optimization 
  BEGIN
	ch0reg<= ch(0) XOR err; -- error was found so correct it
	dout(0)<= ch(0) XOR errcheck; -- suppose that an error has occured
	dout(1 TO m-1)<= ch(1 TO m-1);
	chin(0)<= ch(9);
	chin(1)<= ch0reg;
	chin(2)<= ch(1);
	chin(3)<= ch(2) XOR ch(9);
	chin(4)<= ch(3);
	chin(5)<= ch(4);
	chin(6)<= ch(5);
	chin(7)<= ch(6);
	chin(8)<= ch(7);
	chin(9)<= ch(8);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 1;
END dch1a;


	USE WORK.const.ALL;
ENTITY dch3 IS
PORT (clk, err, errcheck, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch3;

ARCHITECTURE dch3a OF dch3 IS
	SIGNAL ch0reg: BIT;
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 9); -- ch registers and optimization 
  BEGIN
	ch0reg<= ch(0) XOR err; -- error was found so correct it
	dout(0)<= ch(0) XOR errcheck; -- suppose that an error has occured
	dout(1 TO m-1)<= ch(1 TO m-1);
	chin(0)<= ch(7);
	chin(1)<= ch(8);
	chin(2)<= ch(9);
	chin(3)<= ch0reg XOR ch(7);
	chin(4)<= ch(1) XOR ch(8);
	chin(5)<= ch(2) XOR ch(9);
	chin(6)<= ch(3);
	chin(7)<= ch(4);
	chin(8)<= ch(5);
	chin(9)<= ch(6);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 3;
END dch3a;


---------------------------------------------------------------------------
-- decoder circuit
	USE WORK.const.ALL;
ENTITY dec IS
PORT (clk, reset, din: IN BIT; 
	vdout, dout: OUT BIT); 
END dec;

ARCHITECTURE deca OF dec IS
	SIGNAL  pe, cef, cefa, vdout1, din_reset: BIT;
	--pe -parallel enable sr->sc;  er - correct error,
	--vdout - valid data out - remember data register 
	SIGNAL ff1, ff3, err, err1, err2, errcheck, ce, neq: BIT; 
	SIGNAL syn1, syn3: BIT_VECTOR(0 TO m-1); -- syndromes
	SIGNAL ch1, ch3: BIT_VECTOR(0 TO m-1); -- Chien output
	SIGNAL ch1_or: BIT_VECTOR(0 TO m-1);

	COMPONENT deq -- dout<= ( syn1^3 != syn3 )
		PORT (syn1, syn3: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT); 
		END COMPONENT;
		FOR ALL: deq USE ENTITY WORK.deq (deqa);
	COMPONENT ffce  
		PORT (clk, ce, din: IN BIT; 
			dout: OUT BIT); 
		END COMPONENT;
		FOR ALL: ffce USE ENTITY WORK.ffce (ffcea);
	COMPONENT dcount -- counter decoder 
		PORT(clk, reset: IN BIT; cef, pe, vdout, vdout1: OUT BIT); 
		END COMPONENT;
		FOR ALL: dcount USE ENTITY WORK.dcount (dcounta);
	COMPONENT dbuf -- buffer shift registers 
		PORT (clk, err, vdout, din: IN BIT; 
			dout: OUT BIT); 
		END COMPONENT;
		FOR ALL: dbuf USE ENTITY WORK.dbuf (dbufa);
	COMPONENT dsyn1 -- syndrome calculation 
		PORT (clk, pe, din: IN BIT; 
			dout1: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
		FOR ALL: dsyn1 USE ENTITY WORK.dsyn1 (dsyn1a);
	COMPONENT dsyn3 -- syndrome calculation 
		PORT (clk, pe, din: IN BIT; 
			dout3: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
		FOR ALL: dsyn3 USE ENTITY WORK.dsyn3 (dsyn3a);
	COMPONENT dch1 -- Chien's search circuit 
		PORT (clk, err, errcheck, pe: IN BIT;
			 din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
		FOR ALL: dch1 USE ENTITY WORK.dch1 (dch1a);
	COMPONENT dch3 -- Chien's search circuit 
		PORT (clk, err, errcheck, pe: IN BIT;
			 din: IN BIT_VECTOR(0 TO m-1); 
			dout: OUT BIT_VECTOR(0 TO m-1)); 
		END COMPONENT;
		FOR ALL: dch3 USE ENTITY WORK.dch3 (dch3a);

  BEGIN
	c1: dcount
		PORT MAP (clk, reset, cef, pe, vdout, vdout1);
	b1: dbuf
		PORT MAP (clk, err, vdout1, din_reset, dout);
	e1: deq
		PORT MAP (ch1, ch3, neq);
	f1: ffce
		PORT MAP (clk, cefa, ch1_or(m-1), ff1);
	f2: ffce
		PORT MAP (clk, cefa, neq, ff3);
	s1: dsyn1
		PORT MAP (clk, pe, din_reset, syn1); 
	s3: dsyn3
		PORT MAP (clk, pe, din_reset, syn3); 
	h1: dch1
		PORT MAP (clk, err, errcheck, pe, syn1, ch1); 
	h3: dch3
		PORT MAP (clk, err, errcheck, pe, syn3, ch3); 


	din_reset<= din AND NOT reset;

	--  ch1_or eq_or gates
	ch1_or(0)<= ch1(0);
	gen:
	FOR i IN 1 TO m-1 GENERATE
		ch1_or(i)<= ch1_or(i-1) OR ch1(i);
	END GENERATE;	

	-- cefa - clock enable p1, p3 - cepa=1 if start of a new word or err
	cefa <= cef OR err; 
	-- error decision circuit
	err1<= NOT ff3 AND  NOT neq AND ff1 AND NOT ch1_or(m-1); 
		--single err
	err2<= ff1 AND ch1_or(m-1) AND ff3 AND NOT neq; 
		-- double error
	err<= err1 OR err2; -- error has been found
	errcheck<= NOT cef; -- 
END deca;
